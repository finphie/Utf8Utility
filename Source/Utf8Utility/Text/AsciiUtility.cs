using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace Utf8Utility.Text;

/// <summary>
/// Ascii関連のユーティリティクラスです。
/// </summary>
public static class AsciiUtility
{
    const byte IsWhiteSpaceFlag = 0x80;

    // Contains information about the ASCII character range [ U+0000..U+007F ], with:
    // - 0x80 bit if set means 'is whitespace'
    // - 0x40 bit if set means 'is letter or digit'
    // - 0x20 bit is reserved for future use
    // - bottom 5 bits are the UnicodeCategory of the character
    // https://github.com/dotnet/runtime/blob/cebe877f6d1b3d668370f9c6ea068bd1534b8227/src/libraries/System.Private.CoreLib/src/System/Text/Rune.cs#L39-L54
    static ReadOnlySpan<byte> AsciiCharInfo => new byte[]
    {
        0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x8E, 0x8E, 0x8E, 0x8E, 0x8E, 0x0E, 0x0E, // U+0000..U+000F
        0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, // U+0010..U+001F
        0x8B, 0x18, 0x18, 0x18, 0x1A, 0x18, 0x18, 0x18, 0x14, 0x15, 0x18, 0x19, 0x18, 0x13, 0x18, 0x18, // U+0020..U+002F
        0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x18, 0x18, 0x19, 0x19, 0x19, 0x18, // U+0030..U+003F
        0x18, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, // U+0040..U+004F
        0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x14, 0x18, 0x15, 0x1B, 0x12, // U+0050..U+005F
        0x1B, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, // U+0060..U+006F
        0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x14, 0x19, 0x15, 0x19, 0x0E, // U+0070..U+007F
    };

    /// <summary>
    /// 値が空または空白かどうかを判定します。
    /// </summary>
    /// <param name="value">値</param>
    /// <returns>
    /// 値が空または空白の場合は<see langword="true"/>、
    /// それ以外は<see langword="false"/>を返します。
    /// </returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static bool IsWhiteSpace(byte value)
    {
        ref var table = ref MemoryMarshal.GetReference(AsciiCharInfo);
        return (Unsafe.AddByteOffset(ref table, (nint)value) & IsWhiteSpaceFlag) != 0;
    }
}
